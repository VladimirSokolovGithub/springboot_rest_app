Глава 8 - chapter_8_Spring_Boot - рассматривается в отдельном проекте
- springboot_rest_app

ВСЯ ИНФОРМАЦИЯ ТАКЖЕ ЕСТЬ В ПРОЕКТЕ
***********************************************************************
глава - Spring Boot

*** Les_1_Знакомство со Spring Boot ***


Сейчас очень большое количество проектов пишутся не просто на Spring, а
на Spring Boot.

Ранее при создании проектов нам приходилось добавлять множество зависимостей в pom файл
используя maven или же добавлять библиотеки с помощью среды разработки, либо
скачивая jar файлы и вручную добавляя их в проект. Так же мы скачали tomcat и связывали
его с каждым нашим приложением. Вся конфигурация занимала у нас очень много времени.
Слишком много этих конфигураций.

Spring Boot не заменяет обычный Spring, а наоборот Spring Boot использует Spring.

Таким образом Spring Boot позволяет быстро настроить наш проект, делать гораздо меньшее
количество шагов для настройки приложения.

***********************************************************************
глава - Spring Boot

*** Les_2_Создание Spring Boot приложения ***


Рассмотрим два варианта создания Spring Boot приложения.
1-й - будем использовать исключительно среду разработки intelliJIdea
(она так же использует https://start.spring.io)

2-й - общедоступный способ с помощью https://start.spring.io
Открываем в браузере этот сайт https://start.spring.io

***********************************************************************
глава - Spring Boot

*** Les_3_Создание REST API. Часть 1 ***


JPA - Если в нашем коде мы будем использовать не специфичные только для Hibernate методы
и аннотации, а будем использовать стандартный JPA код, то тогда в любое время мы сможем
поменять JPA реализацию с Hibernate на любую другую, без изменения кода нашего приложения.-
- Это best practise.

В properties файле - application.properties мы можем осуществлять множество настроек нашего
Spring Boot приложения. Рассмотрим кроме настройки подключения к БД также настройку нашего
сервера, который по умолчанию является составной частью нашего приложения.
Мы можем например изменить дефолтный порт нашего сервера 8080 скажем на 3333

Так же можем изменить дефолтный домашний адрес нашего приложения.

Со всеми properties, их очень много, можно ознакомиться на официальном сайте spring
https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.core

***********************************************************************
глава - Spring Boot

*** Les_4_Создание REST API. Часть 2 ***


Когда мы делаем какие-либо изменения в коде нашего приложения, нам приходится запускать
приложение заново. Это конечно надоедает. На помощь нам приходит - developer tools.
Для этого нужно добавить зависимость от него в pom файл.

<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <version>2.7.5</version>
</dependency>
При помещении зависимости в pom файл необходимо удалить ее версию, так как за версионность
у нас ответственный - spring-boot-starter-parent, который представлен следующей зависимостью.
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.7.5</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

Этот developer tools будет автоматически делать рестарт нашего приложения, когда увидит
какие-либо изменения в нем.
Так же для того, чтобы devtools автоматически обновлял наше приложение, в среде разработки
в IntelliJ переходим File - Settings - выбираем Build Execution Deployment - выбираем -
- Compiler - и ставим галочку на - Build project automatically.

Далее в IntelliJ нажимаем комбинацию ctrl-shift-a набираем registry и Enter, в
открывшемся окне пишем - compiler.automake.allow.when.app.running - поставить
напротив галочку. (У меня нет такой настройки.). ------------------------------------
------------- Настройка в версии IntelliJ IDEA 2022.1.2 переехала в
File - Settings - Advanced Settings - и поставить галочку в Allow auto-make to start even if
developed applications is currently running. (И все заработало).

***********************************************************************
глава - Spring Boot

*** Les_5_использование JPA в REST API проекте ***


На прошлых уроках мы в нашем проекте использовали функционал Hibernate. Но лучше всего
как показывает best practise использовать классы и методы из JPA. Тогда мы в любой момент
с легкостью сможем сменить реализацию JPA например с Hibernate на какую-то другую.
Мы будем использовать этот же проект, так как изменения в коде будут незначительны и ранее
написанный код будет закомментирован, и мы сможем всегда увидеть разницу.
Все что мы будем менять находится в классе EmployeeDAOImpl т.е в нашем репозитории @Repository.

***********************************************************************
глава - Spring Boot

*** Les_6_интерфейс JpaRepository *** - - рассматривается в отдельном проекте -
- spring_data_jpa


Представим ситуацию, что если мы работаем не с одним Entity - Employee, а таких
Entity у нас несколько, например Entity - House, Entity - Student и т.д.
Получается, что мы должны создавать для каждого Entity интерфейс DAO, прописывать методы
и потом эти методы реализовывать в репозитории *DAOImpl? Т.е. для каждого Entity создавать
новый репозиторий?
Для всех наших Entity большинство методов из EmployeeDAOImpl будут одинаковыми с одинаковой
логикой. Поиск всех объектов в базе данных - getAllEmployees(), потом нахождение Entity
по его id - getEmployee(int id), потом добавление нового Entity или изменение уже
имеющегося saveEmployee(Employee employee), также удаление Entity по его id - deleteEmployee(int id).
НЕТ!
В Spring Boot мы можем вообще не создавать репозиторий для всех Entity. Spring Boot и так
прекрасно и без наших методов знает какие операции с нашими объектами мы захотим реализовывать.
И поэтому определенный список этих операций Spring Boot реализует за нас. А мы можем этим списком
методов просто пользоваться. Единственно что нужно знать, как называются все эти методы в Spring Boot.
Ведь в нашем примере мы сами называли методы в нашем @Repository - EmployeeDAOImpl.

Создадим новый проект - spring_data_jpa
и воспользуемся механизмом, который предоставляет нам Spring Data JPA.

1. Создадим интерфейс EmployeeRepository и extends JpaRepository<Employee, Integer>,
первый дженерик - означает с каким Entity будет работать данный репозиторий,
второй дженерик - означает какой тип данных у поля класса Employee, которое является primary key.
И всё, какие-либо методы в этом интерфейсе прописывать не нужно. И так же нам не нужно создавать
класс, который имплементирует этот интерфейс. Это всё делает за нас Spring Boot.

2. Теперь перейдем к пакету service и интерфейсу EmployeeService и классу EmployeeServiceImpl.
Создадим в классе EmployeeServiceImpl поле -
@Autowired
private EmployeeRepository employeeRepository;

И уже далее с помощью employeeRepository будем вызывать дефолтные методы, которые
предоставляет нам Spring Boot совместно со Spring Data JPA.
С их помощью мы и реализуем наши методы для отображения всех
работников из базы данных, заведения нового работника, изменение существующего и удаления.

3. Если нам нужно получить например список работников по определенному имени, то так же
можно все таки добавить свой метод в репозиторий - интерфейс EmployeeRepository.
Более того Spring Boot совместно со Spring Data JPA при написании имени этого метода,
сразу предлагает уже готовые дефолтные названия по определенным правилам. И если мы
напишем название нашего метода согласно правилам, то и реализовывать нам его не придется,
так как реализация уже будет предоставляться так же Spring Boot, но особое внимание
конечно нужно будет уделить параметрам метода.
После этого создадим наш метод findAllByName в интерфейсе EmployeeService.

***********************************************************************
глава - Spring Boot

*** Les_7_Spring_Data_REST ***


Если у нас несколько Entity, то что получается для каждого Entity мы должны создавать
интерфейс сервис, как EmployeeService? Потом имплементировать этот интерфейс, как EmployeeServiceImpl?
Прописывать все необходимые методы, а так же мы должны для каждого Entity контроллер, как MyRestController?
Создавать все необходимые методы в контроллере, прописывать для них разного типа Mapping-и. Нужно ли это
делать? На самом деле НЕТ!!!

Благодаря Spring Data Rest!

Для этого мы создадим новый проект - spring_data_rest

Для того чтобы мы могли обойтись без контроллеров и сервисов, мы должны добавить в pom файл
от spring-boot-starter-data-rest -

<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-rest</artifactId>
</dependency>

Spring Data Rest предоставляет механизм автоматического создания REST API на основе типа Entity,
прописанного в репозитории проекта.

В нашем приложении REST API создается на основе типа Entity, прописанного в репозитории проекта.
Это означает что Spring будет сканировать репозиторий, а наш репозиторий называется -
- EmployeeRepository посмотрит на его первый дженерик - а это наш Entity тип. И на основе этого
Entity type создаст все необходимые REST API. Создание происходит путем изменения имени нашего
Entity типа, например в Employee заменяется первая буква на прописную и добавляется
в конце множественное число - s, таким образом Employee превращается в - employees.
Таким образом нам не нужен контроллер в котором мы прописываем все наши Mapping-и
так как Spring использует best practice API (смотреть слайд №2).
Такие API создаются by default если мы используем Spring Data Rest и не прописываем
своего контроллера с его Mapping-ами.

Смотреть слайды.

***********************************************************************
глава - Spring Boot

*** Les_8_Знакомство со Spring Boot Actuator ***


Для того чтобы следить за работоспособностью нашего Spring Boot приложения, существует
Spring Boot Actuator.
Благодаря ему нам не нужно писать дополнительный код.

Spring Boot Actuator предоставляет готовые конечные точки (endpoints), с помощью которых
мониторится приложение.
(endpoints - это обычные URL адреса).

Всё что нам нужно сделать, это добавить в pom файл следующую зависимость:
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

Так же для возможности отображать нужную нам информацию посредствам выбранных endpoints
в браузере, в файле application.properties мы можем прописать следующее:

#для выборочных endpoints через запятую.
management.endpoints.web.exposure.include=info,beans,mappings

или

#для всех endpoints
#management.endpoints.web.exposure.include=*

Для того что бы мониторить наше приложение и просматривать endpoints мог не каждый человек,
а только разработчики т.е. люди с правом доступа, необходимо мы можем добавить в проект зависимость
от security:

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
            <scope>runtime</scope>
        </dependency>
При этом Spring Boot сам сгенерирует пароль типа - 5a2d8f62-b599-4327-98d0-920b88cf4f5d
и отобразит его в консоли IntellIJ
Стандартный user name это - "user", ну и далее вводим пароль.

Если мы хотим прописать свои user name и password это можно сделать в файле application.properties

***********************************************************************














